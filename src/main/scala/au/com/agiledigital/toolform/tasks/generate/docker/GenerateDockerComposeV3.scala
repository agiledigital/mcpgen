package au.com.agiledigital.toolform.tasks.generate.docker

import java.io.{BufferedWriter, FileWriter}

import au.com.agiledigital.toolform.app.{ToolFormConfiguration, ToolFormError}
import au.com.agiledigital.toolform.model._
import au.com.agiledigital.toolform.tasks.generate.{WriterContext, YamlWriter}
import au.com.agiledigital.toolform.tasks.generate.docker.DockerFormatting._
import au.com.agiledigital.toolform.tasks.generate.docker.SubEdgeDef.subEdgeDefsFromProject
import au.com.agiledigital.toolform.version.BuildInfo

import scalaz.Scalaz._
import scalaz._

class GenerateDockerComposeV3() extends YamlWriter {

  // TODO: Surely Scalaz has a built in identity function that could replace this.
  // Maybe it could be replaced with a different construct altogether?
  private val identity = State[WriterContext, Unit] { context =>
    (context, ())
  }

  def runDockerComposeV3(toolFormConfiguration: ToolFormConfiguration, project: Project): Either[ToolFormError, String] = {
    val outFile = toolFormConfiguration.generateTaskConfiguration.out
    if (outFile.isDirectory) {
      return Left(ToolFormError("Output path is a directory. Docker Compose V3 output requires a single file as an output."))
    }

    // Logic

    val writer = new BufferedWriter(new FileWriter(outFile, false))
    try {

      val writeFile = for {
        _ <- write(s"# Generated by ${BuildInfo.name} (${BuildInfo.version})")
        _ <- write("version: '3'")
        _ <- write("services:")
        i <- indent()
        _ <- for {
          _ <- writeEdges(project.id, subEdgeDefsFromProject(project).toList)
          _ <- writeComponents(project.id, project.sortedComponents.values.toList)
          _ <- writeResources(project.sortedResources.values.toList)
        } yield ()
        _ <- resetIndent(i)
      } yield ()

      val context = WriterContext(writer)
      writeFile.eval(context)

      Right("Completed Successfully")
    } finally {
      writer.close()
    }
  }

  // Sections

  private[docker] def writeEdges(projectId: String, subEdgeDefs: List[SubEdgeDef]) = State[WriterContext, Unit] { context =>
    (subEdgeDefs
       .traverseU(subEdge => writeSubEdge(projectId, subEdge))
       .exec(context),
     ())
  }

  private[docker] def writeComponents(projectId: String, components: List[Component]) = State[WriterContext, Unit] { context =>
    (components
       .traverseU(component => writeComponent(projectId, component))
       .exec(context),
     ())
  }

  private[docker] def writeResources(resources: List[Resource]) = State[WriterContext, Unit] { context =>
    (resources
       .traverseU(resource => writeResource(resource))
       .exec(context),
     ())
  }

  private[docker] def writeSubEdge(projectId: String, subEdgeDef: SubEdgeDef) = {
    val serviceName = subEdgeServiceName(projectId, subEdgeDef)
    val imageName   = subEdgeImageName(projectId, subEdgeDef)
    for {
      _ <- write(s"$serviceName:")
      i <- indent()
      _ <- for {
        _ <- write(s"image: $imageName")
        _ <- write(s"restart: always")
        _ <- write(s"ports:")
        _ <- write(subEdgePortDefinition(subEdgeDef))
      } yield ()
      _ <- resetIndent(i)
    } yield ()
  }

  private[docker] def writeComponent(projectId: String, component: Component) = {
    val serviceName = componentServiceName(component)
    val imageName   = componentImageName(projectId, component)
    for {
      _ <- write(s"$serviceName:")
      i <- indent()
      _ <- for {
        _ <- write(s"image: $imageName")
        _ <- write(s"restart: always")
        _ <- writeComponentLabels(component)
        _ <- writeEnvironmentVariables(component)
        _ <- writePorts(component)
      } yield ()
      _ <- resetIndent(i)
    } yield ()
  }

  private[docker] def writeComponentLabels(component: Component) =
    for {
      _ <- write("labels:")
      i <- indent()
      _ <- for {
        _ <- write(s"source.path: \042${component.path}\042")
        _ <- write("project.artefact: \"true\"")
      } yield ()
      _ <- resetIndent(i)
    } yield ()

  private[docker] def writeResource(resource: Resource) = {
    val serviceName = resourceServiceName(resource)
    val imageName   = resourceImageName(resource)
    for {
      _ <- write(s"$serviceName:")
      i <- indent()
      _ <- for {

        _ <- write(s"image: $imageName")
        _ <- write(s"restart: always")
        _ <- writeEnvironmentVariables(resource)
        _ <- writePorts(resource)
      } yield ()
      _ <- resetIndent(i)
    } yield ()
  }

  private[docker] def writeEnvironmentVariables(service: Service) = service.environment match {
    case Some(environmentEntries) if environmentEntries.nonEmpty =>
      for {
        _ <- write("environment:")
        _ <- State[WriterContext, Unit] { context =>
          {
            (environmentEntries.toList
               .map((entry) => formatEnvironment(entry))
               .traverseU(write)
               .exec(context),
             ())
          }
        }
      } yield ()
    case _ => identity
  }

  private[docker] def writePorts(service: Service) =
    service.exposedPorts match {
      case Some(ports) if ports.nonEmpty =>
        for {
          _ <- write("ports:")
          _ <- State[WriterContext, Unit] { context =>
            {
              (ports
                 .map((port) => formatPort(port))
                 .traverseU(write)
                 .exec(context),
               ())
            }
          }
        } yield ()
      case _ => identity
    }
}
